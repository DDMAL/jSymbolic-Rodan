import os
import shutil
import jsymbolic_utilities

from rodan.jobs.base import RodanTask


class extract_features(RodanTask):
    name = 'jSymbolic Feature Extractor'
    author = 'Cory McKay and Tristano Tenaglia'
    description = 'Extract features from a music file using the jSymbolic feature extractor'
    settings = {}
    enabled = True
    category = "jSymbolic - Feature Extraction"
    interactive = False

    input_port_types = (
        {
            'name': 'jSymbolic Music File Input',
            'minimum': 1,
            'maximum': 1,
            'resource_types': ['application/mei+xml', 'application/midi']
        },

        {
            'name': 'jSymbolic Configuration File Input',
            'minimum': 0,
            'maximum': 1,
            'resource_types': ['application/jsc+txt']
        },
    )
    output_port_types = (
        {
            'name': 'jSymbolic ACE XML Value Output',
            'minimum': 1,
            'maximum': 1,
            'resource_types': ['application/ace+xml']
        },

        {
            'name': 'jSymbolic ACE XML Definition Output',
            'minimum': 1,
            'maximum': 1,
            'resource_types': ['application/ace+xml']
        },

        {
            'name': 'jSymbolic ARFF Output',
            'minimum': 0,
            'maximum': 1,
            'resource_types': ['application/arff']
        },

        {
            'name': 'jSymbolic ARFF CSV Output',
            'minimum': 0,
            'maximum': 1,
            'resource_types': ['application/arff+csv']
        },
    )

    def run_my_task(self, inputs, settings, outputs):
        music_file = inputs['jSymbolic Music File Input'][0]['resource_path']

        config_file = None
        if inputs['jSymbolic Configuration File Input'][0]['resource_path']:
            config_file = inputs['jSymbolic Configuration File Input'][0]['resource_path']

        java_home = os.environ.get("JAVA_HOME")
        java_jar = "jre/lib/ext/"
        java_directory = os.path.join(java_home, java_jar)
        base_name = os.path.basename(music_file)
        music_name, ext = os.path.splitext(base_name)
        value_file_name = music_name + "_jSymbolic_feature_values.xml"
        definition_file_name = music_name + "_jSymbolic_feature_definitions.xml"

        with self.tempdir() as temp_dir:
            temp_value_path = os.path.join(temp_dir, value_file_name)
            temp_definition_path = os.path.join(temp_dir, definition_file_name)
            if config_file:
                config_input = ['java', '-jar', 'jSymbolic.jar', '-configrun', config_file, music_file, temp_value_path,
                                temp_definition_path]
                return_value, stdout, stderr = jsymbolic_utilities.execute(config_input, java_directory)
            else:
                default_input = ['java', '-jar', 'jSymbolic.jar', music_file, temp_value_path, temp_definition_path]
                return_value, stdout, stderr = jsymbolic_utilities.execute(default_input, java_directory)

            # TODO What to do with the error output from jSymbolic?
            # Return if jsymbolic experienced an error so no further file processing is done
            if stderr:
                return return_value

            # Assign files generated by jSymbolic to value output port
            dst_value_path = os.path.join(outputs['jSymbolic ACE XML Value Output'][0]['resource_path'],
                                          value_file_name)
            shutil.copyfile(temp_value_path, dst_value_path)

            # Assign files generated by jSymbolic to definition output port
            dst_definition_path = os.path.join(outputs['jSymbolic ACE XML Definition Output'][0]['resource_path'],
                                               definition_file_name)
            shutil.copyfile(temp_definition_path, dst_definition_path)

            # Split up filename and extension for arff and csv files
            pre, ext = os.path.splitext(value_file_name)

            # Try to get arff file if it exists, otherwise continue
            arff_name = "{0}.arff".format(pre)
            src_arff_file_path = os.path.join(temp_dir, arff_name)
            dst_arff_file_path = os.path.join(outputs['jSymbolic ARFF Output'][0]['resource_path'], arff_name)
            jsymbolic_utilities.copy_when_exists(src_arff_file_path, dst_arff_file_path)

            # Try to get csv file if it exists, otherwise continue
            csv_name = "{0}.csv".format(pre)
            src_csv_file_path = os.path.join(temp_dir, csv_name)
            dst_csv_file_path = os.path.join(outputs['jSymbolic ARFF CSV Output'][0]['resource_path'], csv_name)
            jsymbolic_utilities.copy_when_exists(src_csv_file_path, dst_csv_file_path)

        return return_value

    def test_my_task(self, testcase):
        # No tests for now
        pass
